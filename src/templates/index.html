<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCPBro Chat</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.1.5/purify.min.js" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.5/socket.io.min.js"></script>
</head>
<body>
    <h1>MCPBro Chat (Dark)</h1>
    <div class="chat-container">
        <div class="chat-history" id="chat-history">
            {% for message in chat_history %}
                <div class="message {{ message.type }}" {% if message.type == 'model' %}data-markdown-content="{{ message.text }}"{% endif %}>
                    <span class="sender">{{ message.type.capitalize() }}:</span>
                    <div class="text" style="white-space: pre-wrap;">{{ message.text }}</div>
                </div>
            {% endfor %}
        </div>
        <div class="chat-input">
            <form id="chat-form" action="javascript:sendMessage();">
                <input type="text" id="prompt" name="prompt" placeholder="Enter your message..." autocomplete="off" required>
                <button type="submit">Send</button>
            </form>
            <div class="controls">
                <a href="{{ url_for('reset') }}" class="reset-button">Reset Chat</a>
                <span id="status-indicator" class="status-idle">Idle</span>
            </div>
        </div>
    </div>

    <script>
        const chatHistory = document.getElementById('chat-history');
        const promptInput = document.getElementById('prompt');
        const chatForm = document.getElementById('chat-form');
        const statusIndicator = document.getElementById('status-indicator');
        const socket = io();

        function scrollToBottom() {
            setTimeout(() => {
                chatHistory.scrollTop = chatHistory.scrollHeight;
            }, 50);
        }

        function renderMarkdownAndHighlight(element) {
            if (!element || typeof marked === 'undefined' || typeof DOMPurify === 'undefined') {
                console.warn('Markdown rendering prerequisites not met for element:', element);
                return;
            }

            const textDiv = element.querySelector('.text');
            const rawMarkdown = element.getAttribute('data-markdown-content');

            if (!textDiv || rawMarkdown === null) {
                if (textDiv) textDiv.style.whiteSpace = 'pre-wrap';
                return;
            }

            try {
                const dirtyHtml = marked.parse(rawMarkdown);
                const cleanHtml = DOMPurify.sanitize(dirtyHtml);
                textDiv.innerHTML = cleanHtml;
                textDiv.style.whiteSpace = 'normal';

                if (typeof hljs !== 'undefined') {
                    const codeBlocks = textDiv.querySelectorAll('pre code');
                    codeBlocks.forEach((block) => {
                        try {
                            hljs.highlightElement(block);
                        } catch (highlightError) {
                            console.error('Highlight.js error:', highlightError, 'on block:', block);
                        }
                    });
                } else {
                    console.warn('highlight.js not loaded, skipping syntax highlighting.');
                }
            } catch (error) {
                console.error('Error processing Markdown/Highlighting:', error);
                textDiv.textContent = rawMarkdown;
                textDiv.style.whiteSpace = 'pre-wrap';
            }
        }

        function addMessage(type, text) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', type);

            const senderSpan = document.createElement('span');
            senderSpan.classList.add('sender');
            senderSpan.textContent = `${type.charAt(0).toUpperCase() + type.slice(1)}:`;
            messageDiv.appendChild(senderSpan);

            const textDiv = document.createElement('div');
            textDiv.classList.add('text');

            if (type === 'model') {
                messageDiv.setAttribute('data-markdown-content', text);
                textDiv.style.whiteSpace = 'pre-wrap';
                textDiv.textContent = text;
                messageDiv.appendChild(textDiv);
                renderMarkdownAndHighlight(messageDiv);
            } else {
                textDiv.textContent = text;
                textDiv.style.whiteSpace = 'pre-wrap';
                messageDiv.appendChild(textDiv);
            }

            chatHistory.appendChild(messageDiv);
            scrollToBottom();
        }

        function sendMessage() {
            const prompt = promptInput.value.trim();
            if (prompt) {
                console.log('Sending message:', prompt);
                socket.emit('send_message', { prompt: prompt });
                promptInput.value = '';
            }
        }

        socket.on('connect', () => {
            console.log('Socket.IO connected:', socket.id);
            statusIndicator.textContent = 'Connected';
            statusIndicator.className = 'status-connected';
        });

        socket.on('disconnect', () => {
            console.log('Socket.IO disconnected');
            statusIndicator.textContent = 'Disconnected';
            statusIndicator.className = 'status-disconnected';
        });

        socket.on('connect_error', (err) => {
            console.error('Socket.IO connection error:', err);
            statusIndicator.textContent = 'Connection Error';
            statusIndicator.className = 'status-disconnected';
            addMessage('error', `Connection failed: ${err.message}. Please check the server and refresh.`);
        });

        socket.on('new_message', (data) => {
            console.log('Received message:', data);
            addMessage(data.type, data.text);
        });

        socket.on('status_update', (data) => {
            console.log('Status update:', data.message);
            statusIndicator.textContent = data.message;
            if (data.message === 'Processing...') {
                statusIndicator.className = 'status-processing';
            } else if (statusIndicator.textContent === 'Connected') {
                statusIndicator.className = 'status-connected';
            } else {
                statusIndicator.className = 'status-idle';
            }
        });

        socket.on('error', (data) => {
            console.error('Server error:', data.message);
            addMessage('error', `Server Error: ${data.message}`);
            statusIndicator.textContent = 'Error';
            statusIndicator.className = 'status-disconnected';
        });

        socket.on('history_reset', () => {
            console.log('History reset signal received.');
        });

        window.onload = () => {
            document.querySelectorAll('.message.model[data-markdown-content]').forEach(element => {
                renderMarkdownAndHighlight(element);
            });
            scrollToBottom();
        };
    </script>
</body>
</html>
